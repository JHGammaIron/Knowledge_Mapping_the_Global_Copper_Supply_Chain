# -*- coding: utf-8 -*-
"""Distributed View Matrix.ipynb

Automatically generated by Colab.

"""


# Use this
import pandas as pd
import numpy as np

file_name = 'subset_ownership.csv'
# path_name = './drive/MyDrive/Nserc/'
path_name = './' # use this path name for items in content (default) folder

saved_df = pd.read_csv(path_name + file_name, index_col=0)

"""# Configure Settings"""

#@title Init
index = saved_df.index
columns = saved_df.columns.drop("Number of Heuristic Flows")

index_countries = []
for value in index:
  country = value.split("[Country:")[1].split("]")[0].strip()
  index_countries.append(country)

columns_countries = []
for value in columns[:-1]:
  country = value.split("[Country:")[1].split("]")[0].strip()
  columns_countries.append(country)

"""(Command + Click) to select multiple values (Mac)

(CTRL + Click) to select mulitple values (Windows)
"""

#@title Select Mines by Country(s) (Run only once)
import ipywidgets as widgets
from IPython.display import display


multi_select = widgets.SelectMultiple(
    options=sorted(set(index_countries)),
    value=['Chile'],
    description='Mines:',
)

display(multi_select)

def on_change(change):
    if change['type'] == 'change' and change['name'] == 'value':
        print("Selected:", change['new'])

multi_select.observe(on_change)

#@title Select Smelters by Country(s) (Run only once)
import ipywidgets as widgets
from IPython.display import display


multi_select_2 = widgets.SelectMultiple(
    options=sorted(set(columns_countries)),
    value=['Chile'],
    # value=['China'],
    description='Smelters:',
)

display(multi_select_2)

def on_change(change):
    if change['type'] == 'change' and change['name'] == 'value':
        print("Selected:", change['new'])

multi_select_2.observe(on_change)

#@title Run to Show Full Matrix
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
# pd.set_option('display.width', 1000)
pd.set_option('display.max_colwidth', None)

#@title Run to Show Condensed Matrix
pd.reset_option('display.max_rows')
pd.reset_option('display.max_columns')
pd.reset_option('display.width')
pd.reset_option('display.max_colwidth')

"""# Matrix (Rerun with each setting change)

Some entries are 0, due to the fact that some mines (despite operating), have a capacity of 0 (in the dataset).

With the 'same country' heuristic, we see more mines show up in the table. This is because we filter for mines that possess at least one heuristic flow. The 'same country' heuristic adds thousands of flows, therefore adding to the mines that possess at least one flow. Therefore together, more mines will show up in the table below.

Table below only shows mines that have at least one heuristic flow.
"""

#@title Matrix
Mine_Countries = multi_select.value

Smelter_Countries = multi_select_2.value

columns_to_keep = []
if "Number of Heuristic Flows" in saved_df.columns:
  columns_to_keep = ["Number of Heuristic Flows"]

for value in columns[:-1]:
  country = value.split("[Country:")[1].split("]")[0].strip()
  if country in Smelter_Countries:
    columns_to_keep.append(value)

rows_to_keep = []
for value in index:
  country = value.split("[Country:")[1].split("]")[0].strip()
  if country in Mine_Countries:
    rows_to_keep.append(value)

if Smelter_Countries == []:
  columns_to_keep = columns[:-1]

if Mine_Countries == []:
  rows_to_keep = index


df = saved_df[saved_df.index.isin(rows_to_keep)][columns_to_keep]
df.rename(columns={'Number of Heuristic Flows': 'Number of Global Heuristic Flows'}, inplace=True)
nonzero_counts = df.apply(np.count_nonzero, axis=1)
df.insert(1, "Number of Flows (in this specific submatrix)", nonzero_counts-1)
df

"""# Sankey (Rerun to make changes)"""

#@title Sankey Diagram
import plotly.graph_objects as go

mine_labels = df.index.tolist()
smelter_labels = df.columns.drop("Number of Global Heuristic Flows").drop("Number of Flows (in this specific submatrix)").tolist()

source = []
target = []
values = []


for i in range(len(mine_labels)):
  for j in range(len(smelter_labels)):
    # # Change if needed
    # if df.iloc[i, j+2] > 0.5:
    if df.iloc[i, j+2] != 0:
      source.append(i)
      target.append(j + len(mine_labels))
      values.append(df.iloc[i, j+2])
      # print(source, target, value)

labels = mine_labels + smelter_labels

# aggregate_source = []
# aggregate_target = []
# aggregate_values = []

fig = go.Figure(go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        # line=dict(color="black", width=0.5),
        label=labels,
        align="right",
    ),
    link=dict(
        arrowlen=15,
        source=source,
        target=target,
        value=values,
        # color=aggregate_colors
    )
))

#Change Diagram Title
fig.update_layout(
    title_text="Mine to Smelter Flows (Thousand Metric Tons)",
    # title_text="Mine to Smelter Flows (above 500 metric tons)",
    # font=dict(
        # size=20,
        # color="black"
    # ),
    width=1600,
    height=800,
    hoverlabel=dict(
        font_size=20
    )
)
fig.show()

"""Units in Thousand Metric Tons
