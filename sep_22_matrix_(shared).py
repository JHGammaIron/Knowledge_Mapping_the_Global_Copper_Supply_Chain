# -*- coding: utf-8 -*-
"""Sep 22 Matrix (Shared).ipynb

Automatically generated by Colab.

"""


import pandas as pd
import numpy as np

orig_comtrade_df = pd.read_csv('./drive/MyDrive/Nserc/2603_2022_Import_Export_Aug_18.csv')

orig_mines_df = pd.read_excel('./drive/MyDrive/Nserc/REDACTED.xlsx', sheet_name='Mines')
# orig_mines_df
# comtrade_df

"""#This code is used for inferring the solution matrix

Add files + path name (above)


---


In the section "linear programming #9 Aug 26", uncomment the code marked as 'Aug 21' to use code related to the compatibility heuristic.

Tip: For quick search, find: "Uncomment to add compatibility constraint"

---

The sections with the word "Test" in the name, do not affect the code. However, they can provide some useful information.



---



The three sections, "Setup, Initialize, and Linear Programming Setup", processes and prepares the data in some way to be used by the linear programming solver.

"Linear programming Ownership" uses only ownership as a heuristic. (It outputs its own solution matrix)

"Linear Programming Ownership + Same Country" uses both ownership and being in the same country as a heuristic. (It outputs its own solution matrix)

"Parse Dataframe" does some processing to extract the flows (specifically mines) which we have heuristic information for. It as well prepares the data and outputs it as a CSV file. For this, you might have to modify the path name. The CSV file that it outputs and saves can be directly used in the "View Matrix' Colab notebook.

# Init
"""

# orig_mines_df.groupby('Country').count()

# orig_mines_df.count()

export_comtrade_df = orig_comtrade_df
# Only this is needed
export_comtrade_df = export_comtrade_df[export_comtrade_df['partnerDesc'] != "World"]
# Not needed
export_comtrade_df = export_comtrade_df[export_comtrade_df['cmdDesc'] == 'Copper ores and concentrates']
export_comtrade_df = export_comtrade_df[export_comtrade_df['flowDesc'] == "Export"]
export_comtrade_df = export_comtrade_df[export_comtrade_df['refYear'] == 2022]
# export_comtrade_df

import_comtrade_df = orig_comtrade_df
# Only this is needed
import_comtrade_df = import_comtrade_df[import_comtrade_df['partnerDesc'] != "World"]
# Not needed
import_comtrade_df = import_comtrade_df[import_comtrade_df['cmdDesc'] == 'Copper ores and concentrates']
import_comtrade_df = import_comtrade_df[import_comtrade_df['flowDesc'] == "Import"]
import_comtrade_df = import_comtrade_df[import_comtrade_df['refYear'] == 2022]
# import_comtrade_df

orig_smelters_df = pd.read_excel('./drive/MyDrive/Nserc/REDACTED.xlsx', sheet_name='Smelters')
# orig_smelters_df

mines_df = orig_mines_df
mines_df.columns = mines_df.iloc[1]
mines_df = mines_df.iloc[2:].reset_index(drop=True)
# mines_df.head()

smelters_df = orig_smelters_df
smelters_df.columns = smelters_df.iloc[1]
smelters_df = smelters_df.iloc[2:].reset_index(drop=True)
# smelters_df

mines_clean_df = mines_df
mines_clean_df = mines_clean_df[mines_clean_df['Status'] == 'Operating']
mines_clean_df = mines_clean_df.dropna(subset=['Country'])
# mines_clean_df

smelters_clean_df = smelters_df
smelters_clean_df = smelters_clean_df[smelters_clean_df['Status'] == 'Operating']
smelters_clean_df = smelters_clean_df.dropna(subset=['Country'])
# smelters_clean_df

mines_2022_df = mines_clean_df
mines_2022_df = mines_2022_df.dropna(subset=[2022.0]).reset_index(drop=True)
# mines_2022_df
smelters_2022_df = smelters_clean_df
smelters_2022_df = smelters_2022_df.dropna(subset=[2022.0]).reset_index(drop=True)
# smelters_2022_df



"""# Test (Mass Balance)"""

#@title Mass Balance Function

def mass_balance(comtrade_country, ICSG_country):

  mines_output = mines_2022_df[mines_2022_df['Country'] == ICSG_country][2022].sum()

  comtrade_reporter_export = export_comtrade_df[export_comtrade_df['reporterDesc'] == comtrade_country]['netWgt'].sum()/1000000
  comtrade_partner_export = export_comtrade_df[export_comtrade_df['partnerDesc'] == comtrade_country]['netWgt'].sum()/1000000

  comtrade_reporter_import = import_comtrade_df[import_comtrade_df['reporterDesc'] == comtrade_country]['netWgt'].sum()/1000000
  comtrade_partner_import = import_comtrade_df[import_comtrade_df['partnerDesc'] == comtrade_country]['netWgt'].sum()/1000000

  smelters_input = smelters_2022_df[smelters_2022_df['Country'] == ICSG_country][2022].sum()

  print(comtrade_country, "Mines Output:                                 ", mines_output)
  print(comtrade_country, "Smelters Input:                               ", smelters_input)
  print()

  print(comtrade_country, "-> Other Countries (HS 2603 Reporter Export): ", comtrade_reporter_export)
  print(comtrade_country, "<- Other Countries (HS 2603 Partner Export):  ", comtrade_partner_export)

  print(comtrade_country, "<- Other Countries (HS 2603 Reporter Import): ", comtrade_reporter_import)
  print(comtrade_country, "-> Other Countries (HS 2603 Partner Import):  ", comtrade_partner_import)

  print()
  print(comtrade_country, "-> Going into storage:                        ", mines_output - comtrade_reporter_export + comtrade_partner_export - smelters_input)

#@title Chile
comtrade_country = 'Chile'
ICSG_country = 'Chile'

mass_balance(comtrade_country, ICSG_country)

#@title Peru
comtrade_country = 'Peru'
ICSG_country = 'Peru'

mass_balance(comtrade_country, ICSG_country)

#@title China
comtrade_country = 'China'
ICSG_country = 'China'

mass_balance(comtrade_country, ICSG_country)

#@title USA
comtrade_country = 'USA'
ICSG_country = 'United States'

mass_balance(comtrade_country, ICSG_country)

"""# Submatrix Test"""

mine_total_test = mines_2022_df.groupby('Country').count()
mine_total_test

mines_2022_df.count()

smelter_total_test = smelters_2022_df.groupby('Country').count()
smelter_total_test

"""# Setup"""

"Country: " + mines_2022_df['Country'] + " \n Mine: " + mines_2022_df['Mine']

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

sum_of_rows = mines_2022_df[2022.0]
sum_of_cols = smelters_2022_df[2022.0]
row_index = "[Country: " + mines_2022_df['Country'] + "] [Mine: " + mines_2022_df['Mine'] + "]"
row_index = pd.concat([row_index, pd.Series(['Sum of Importers'])])

col_index = "[Country: " + smelters_2022_df['Country'] + "] [Smelter: " + smelters_2022_df['Smelters'] + "]"
col_index = pd.concat([col_index, pd.Series(['Sum of Exporters'])])


matrix = np.zeros((len(row_index), len(col_index)))

for i in range(matrix.shape[0] - 1):
    matrix[i,-1] = sum_of_rows[i]

for j in range(matrix.shape[1] - 1):
    matrix[-1,j] = sum_of_cols[j]



df1 = pd.DataFrame(matrix, index=row_index, columns=col_index)
df1

mines_2022_df[2022.0]

mines_2022_df['Mine']

country_name_map = {
    #REDACTED
}
country_name_map_new = {v: k for k, v in country_name_map.items()}

"""# Initialize"""

sum_of_rows = mines_2022_df[2022.0]
sum_of_cols = smelters_2022_df[2022.0]

country_sums = {}

for mine_country in mines_2022_df['Country'].unique().tolist():
  for smelter_country in smelters_2022_df['Country'].unique().tolist():

    temp_df = export_comtrade_df[(export_comtrade_df['reporterDesc'] == country_name_map_new[mine_country]) & (export_comtrade_df['partnerDesc'] == country_name_map_new[smelter_country])]
    if np.sum(temp_df['netWgt']) == 0:
      continue
    country_sums[mine_country, smelter_country] = np.sum(temp_df['netWgt'])/1000000
country_sums


"""# Linear Programming Setup"""

mines_2022_df['Operator/Owner(s)'] = mines_2022_df.groupby(['Country', 'Mine'])['Operator/Owner(s)'].ffill()
smelters_2022_df['Operator/Owner(s)'] = smelters_2022_df.groupby(['Country', 'Smelters'])['Operator/Owner(s)'].ffill()

import re

def clean_company_names(text):

    if text is None:
        return []

    text = str(text)
    parts = re.split(r'[(),]', text)

    cleaned = []
    for part in parts:
        no_percent = re.sub(r'\d+(\.\d+)?\s*%', '', part)
        name = no_percent.strip()
        if name:
            cleaned.append(name)
    return cleaned

mines_2022_df['new_col'] = mines_2022_df['Operator/Owner(s)'].apply(clean_company_names)
smelters_2022_df['new_col'] = smelters_2022_df['Operator/Owner(s)'].apply(clean_company_names)

# Indexed by: [Mine -> Smelter]
ownership = {}

for index1, row1 in mines_2022_df.iterrows():
  for index2, row2 in smelters_2022_df.iterrows():
    shared_elements = set(row1['new_col']) & set(row2['new_col'])
    if shared_elements:
      ownership[index1, index2] = 1
    else:
      ownership[index1, index2] = 0

# Indexed by: [Mine -> Smelter]
same_country = {}

for index1, row1 in mines_2022_df.iterrows():
  for index2, row2 in smelters_2022_df.iterrows():
    if row1['Country'] == row2['Country']:
      same_country[index1, index2] = 1
    else:
      same_country[index1, index2] = 0

#@title Incompatibility Heuristic

incompatible_materials_by_process = {
    #REDACTED
}

import re

def extract_all_companies(text):

    if text is None:
      return []

    text = str(text)
    parts = re.split(',', text)
    cleaned = []
    for part in parts:
        part = part.strip()
        if part:
            cleaned.append(part.strip())
    return cleaned

mines_2022_df['new_col'] = mines_2022_df['Other Metals'].apply(extract_all_companies)

smelters_2022_df['incompatible_materials'] = smelters_2022_df['Process'].apply(lambda x: incompatible_materials_by_process.get(x, set()))

#@title Heuristic Matrix 6 Same_Ownership
import cvxpy as cp
import numpy as np

def heuristic_matrix_6(row_index, col_index, ownership):



  heuristic_matrix = np.zeros((len(row_index)-1, len(col_index)-1))

  if matrix.shape[0] > matrix.shape[1]:
    for i,j in ownership:
      if ownership[i, j] == 1:
        heuristic_matrix[i,j] = matrix[i,-1]
  else:
    for i,j in ownership:
      if ownership[i, j] == 1:
        heuristic_matrix[i,j] = matrix[-1,j]

  return heuristic_matrix

#@title Heuristic Matrix 7 (Added same_country)
import cvxpy as cp
import numpy as np

def heuristic_matrix_7(row_index, col_index, ownership):



  heuristic_matrix = np.zeros((len(row_index)-1, len(col_index)-1))


  if matrix.shape[0] > matrix.shape[1]:
    for i,j in ownership:
      if ownership[i, j] == 1:
        heuristic_matrix[i,j] = matrix[i,-1]
  else:
    for i,j in ownership:
      if ownership[i, j] == 1:
        heuristic_matrix[i,j] = matrix[-1,j]

  if matrix.shape[0] > matrix.shape[1]:
    for i,j in same_country:
      if i == 109 and j == 14:
        print(same_country[i,j])
        print(row_index[i])
        print(col_index[j])
      if same_country[i, j] == 1:
        heuristic_matrix[i,j] = matrix[i,-1]
  else:
    for i,j in same_country:
      if same_country[i, j] == 1:
        heuristic_matrix[i,j] = matrix[-1,j]


  return heuristic_matrix

#@title A b #2
def set_A_b(row_index, col_index):

    n_rows = len(row_index) - 1
    n_cols = len(col_index) - 1

    sum_of_rows = matrix[:-1, -1]
    sum_of_cols = matrix[-1, :-1]

    submatrices = []
    mine_country_to_indices = {country: mines_2022_df[mines_2022_df['Country'] == country].index.tolist() for country in mines_2022_df['Country'].unique()}
    smelter_country_to_indices = {country: smelters_2022_df[smelters_2022_df['Country'] == country].index.tolist() for country in smelters_2022_df['Country'].unique()}

    for country1 in mines_2022_df['Country'].unique().tolist():
      for country2 in smelters_2022_df['Country'].unique().tolist():
        if (country1, country2) in country_sums:
            submatrices.append(country_sums[country1, country2])


    b = np.concatenate([sum_of_rows, sum_of_cols, submatrices])
    n_submatrices = len(submatrices)
    A = np.zeros((len(b), n_rows * n_cols))

    def idx(i,j): return i * n_cols + j

    for i in range(n_rows):
        for j in range(n_cols):
            A[i, idx(i,j)] = 1

    for j in range(n_cols):
        for i in range(n_rows):
            A[n_rows + j, idx(i,j)] = 1

    k = n_rows + n_cols
    for country1 in mines_2022_df['Country'].unique().tolist():
        for country2 in smelters_2022_df['Country'].unique().tolist():
            if (country1, country2) in country_sums:
                mine_indices = mine_country_to_indices[country1]
                smelter_indices = smelter_country_to_indices[country2]

                temp = np.zeros((n_rows, n_cols))
                for r_idx in mine_indices:
                    for c_idx in smelter_indices:
                        temp[r_idx, c_idx] = 1

                A[k] = temp.flatten()
                k += 1


    return A, b

#@title Linear Programming #9 Aug 26

import cvxpy as cp
import random
import scipy


def quad_prog_9(ownership, row_index, col_index, lambda_reg, P_prior):


  n_rows = len(row_index) - 1
  n_cols = len(col_index) - 1

  P = cp.Variable((n_rows, n_cols))


  A, b = set_A_b(row_index, col_index)




  # EDIT Aug 21 =======================================================>
  s = cp.Variable(len(col_index[:-1]))
  s3 = cp.Variable(len(b) - len(row_index[:-1]) - len(col_index[:-1]))
  constraints = [
      cp.sum(P, axis=1) == matrix[:-1,-1],

      cp.sum(P, axis=0) + s == matrix[-1,:-1],
      P >= 0,
  ]


  submatrices = []
  mine_country_to_indices = {country: mines_2022_df[mines_2022_df['Country'] == country].index.tolist() for country in mines_2022_df['Country'].unique()}
  smelter_country_to_indices = {country: smelters_2022_df[smelters_2022_df['Country'] == country].index.tolist() for country in smelters_2022_df['Country'].unique()}

  k = 0
  for country1 in mines_2022_df['Country'].unique().tolist():
    for country2 in smelters_2022_df['Country'].unique().tolist():
      if (country1, country2) in country_sums:
        mine_indices = mine_country_to_indices[country1]
        smelter_indices = smelter_country_to_indices[country2]

        submatrix_list = []
        for r_idx in mine_indices:
          for c_idx in smelter_indices:
            submatrix_list.append(P[r_idx, c_idx])
        constraints.append(cp.sum(submatrix_list) + s3[k] == country_sums[country1, country2])
        k += 1
      

  # rho = 10000
  rho = 100

  delta = 1.0

  objective = cp.Minimize(cp.sum(cp.huber(P - P_prior, M=delta)) + cp.norm1(s) + rho *(cp.norm1(s3)))


  problem = cp.Problem(objective, constraints)
  problem.solve(verbose=True, max_iter=50000, scaling=True, eps_abs=1e-3,
           eps_rel=1e-3)
  print("Problem status:", problem.status)

  P_value = P.value

  sol_heuristic_matrix = np.zeros((len(row_index), len(col_index)))
  sol_heuristic_matrix[0:-1,0:-1] = P_value

  for i in range(sol_heuristic_matrix.shape[0]):
      sol_heuristic_matrix[i,-1] = np.sum(sol_heuristic_matrix[i,:])

  for j in range(sol_heuristic_matrix.shape[1]):
      sol_heuristic_matrix[-1,j] = np.sum(sol_heuristic_matrix[:,j])

  sol_heuristic_matrix[-1,:-1] += s.value

  sol_heuristic_matrix[sol_heuristic_matrix < 0.01] = 0

  if show:
    df4 = pd.DataFrame(sol_heuristic_matrix, index=row_index, columns=col_index)

    plt.figure(figsize=(14, 10))
    sns.heatmap(df4, annot=True, fmt='.2f', cmap='Blues')
    plt.title("Quadratic Programming Heuristic Matrix")
    plt.tight_layout()
    plt.show()

  s2 = None

  return sol_heuristic_matrix, s, s2

"""# Linear Programming Ownership Sep 3"""

#@title Ownership

lambda_reg = 1

show = False

P_prior_ownership = heuristic_matrix_6(row_index, col_index, ownership)



sol_heuristic_matrix, s, s2 = quad_prog_9(ownership, row_index, col_index, lambda_reg, P_prior_ownership)
ownership_solution_df = pd.DataFrame(sol_heuristic_matrix, index=row_index, columns=col_index)

path_name = 'drive/MyDrive/Nserc/'

ownership_solution_df.to_csv(path_name + "saved_ownership.csv")
ownership_solution_df

"""# Linear Programming Ownership + Same Country Sep 3"""

#@title Ownership + Same Country

lambda_reg = 1

show = False

P_prior_ownership_same_country = heuristic_matrix_7(row_index, col_index, ownership)



sol_heuristic_matrix, s, s2 = quad_prog_9(ownership, row_index, col_index, lambda_reg, P_prior_ownership_same_country)
ownership_same_country_solution_df = pd.DataFrame(sol_heuristic_matrix, index=row_index, columns=col_index)

path_name = 'drive/MyDrive/Nserc/'
ownership_same_country_solution_df.to_csv(path_name + "saved_ownership_same_country.csv")

ownership_same_country_solution_df

"""# Parse Dataframe Sep 3"""

path_name = 'drive/MyDrive/Nserc/'

saved_ownership_df = pd.read_csv('./' + path_name + 'saved_ownership.csv', index_col=0)
saved_ownership_same_country_df = pd.read_csv('./' + path_name + 'saved_ownership_same_country.csv', index_col=0)

def parsing_df(P_prior_new, saved_df_new, file_name, only_heuristic):
  if only_heuristic:
    saved_df_new.iloc[:-1,:-1] = saved_df_new.iloc[:-1,:-1].mask(P_prior_new == 0, 0)




  P_prior_df = pd.DataFrame(P_prior_new, index=row_index[:-1])
  test1 = P_prior_df.sum(axis=1)
  subset_df = saved_df_new[:-1][test1 != 0]



  P_prior_df = pd.DataFrame(P_prior_new, index=row_index[:-1], columns=col_index[:-1])

  nonzero_counts = P_prior_df.apply(np.count_nonzero, axis=1)
  nonzero_counts = nonzero_counts.rename("Number of Heuristic Flows")
  same_country_temp = pd.concat([nonzero_counts, saved_df_new.iloc[:-1,:-1]], axis=1)

  test1 = P_prior_df.sum(axis=1)
  subset_same_country_df = same_country_temp[test1 != 0]
  subset_same_country_df.to_csv(file_name)

# file_name = 'subset_ownership.csv'
path_name = 'drive/MyDrive/Nserc/'

parsing_df(P_prior_ownership, saved_ownership_df, path_name + "subset_ownership.csv", False)
parsing_df(P_prior_ownership, saved_ownership_df, path_name + "only_heuristic_subset_ownership.csv", True)
parsing_df(P_prior_ownership_same_country, saved_ownership_same_country_df, path_name + "subset_ownership_same_country.csv", False)
parsing_df(P_prior_ownership_same_country, saved_ownership_same_country_df, path_name + "only_heuristic_subset_ownership_same_country.csv", True)

"""# Some Tests

Some entries are 0, due to the fact that some mines (despite operating), have a capacity of 0.
"""

P_prior_ownership_same_country = heuristic_matrix_7(row_index, col_index, ownership)

P_prior_df_temp = pd.DataFrame(P_prior_ownership_same_country, index=row_index[:-1], columns=col_index[:-1])
P_prior_df_temp.iloc[90:150,10:20]

P_prior_df_temp.iloc[109:110,10:20]

same_country[109,14]