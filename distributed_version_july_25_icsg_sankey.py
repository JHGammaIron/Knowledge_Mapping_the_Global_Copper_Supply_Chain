# -*- coding: utf-8 -*-
"""Distributed Version July 25 ICSG sankey.ipynb

Automatically generated by Colab.

**Load dataset** into the files menu of google colab and replace path/file name with appropriate file name and path.

Click **Run all** in the Google Colab menu at the top of the page, to run all cells all at once.

After any changes in parameters, rerun main Sankey Diagram cell (no need to rerun other cells - they only need to be run once - unless it does not display properly the first time).

To select multiple items in the search box menu, hold down **Command/Control** and select the desired options

Small warning: The searchbox selection can be somewhat unreliable. Might have to be rerun more than once for it to render properly.
"""

import pandas as pd
import numpy as np

# Change file/path name as needed

# You should only need to change the path name (I did not modify any file names)

# Comtrade data
comtrade_path = './drive/MyDrive/Nserc/'
comtrade_file = '2022_Sankey_July_21.csv'

all_df = pd.read_csv(comtrade_path + comtrade_file)

# ICSG data
ICSG_path = './drive/MyDrive/Nserc/'
ICSG_file = 'REDACTED.xlsx'

orig_mines_df = pd.read_excel(ICSG_path + ICSG_file, sheet_name='Mines')
orig_smelters_df = pd.read_excel(ICSG_path + ICSG_file, sheet_name='Smelters')
orig_refineries_df = pd.read_excel(ICSG_path + ICSG_file, sheet_name='Refineries')

#@title Init
mines_df = orig_mines_df
smelters_df = orig_smelters_df
refineries_df = orig_refineries_df

mines_df.columns = mines_df.iloc[1]
mines_df = mines_df.iloc[2:].reset_index(drop=True)
mines_df = mines_df[mines_df['Status'] == 'Operating']
mines_df = mines_df.dropna(subset=['Country'])
mines_df = mines_df.dropna(subset=[2022.0]).reset_index(drop=True)
init_mines_df = mines_df.copy().sort_values(by='Mine', ascending=True)

smelters_df.columns = smelters_df.iloc[1]
smelters_df = smelters_df.iloc[2:].reset_index(drop=True)
smelters_df = smelters_df[smelters_df['Status'] == 'Operating']
smelters_df = smelters_df.dropna(subset=['Country'])
smelters_df = smelters_df.dropna(subset=[2022.0]).reset_index(drop=True)
init_smelters_df = smelters_df.copy().sort_values(by='Smelters', ascending=True)

refineries_df.columns = refineries_df.iloc[1]
refineries_df = refineries_df.iloc[2:].reset_index(drop=True)
refineries_df = refineries_df[refineries_df['Status'] == 'Operating']
refineries_df = refineries_df.dropna(subset=['Country'])
refineries_df = refineries_df.dropna(subset=[2022.0]).reset_index(drop=True)
init_refineries_df = refineries_df.copy().sort_values(by='Refineries', ascending=True)

#@title Number of Mines to Display

import ipywidgets as widgets
from IPython.display import display

number_of_mines = widgets.IntText(
    value=25,
    description='Number of Mines to Display:',
    disabled=False
)

display(number_of_mines)

#@title Number of Smelters to Display

import ipywidgets as widgets
from IPython.display import display

number_of_smelters = widgets.IntText(
    value=25,
    description='Number of Smelters to Display:',
    disabled=False
)

display(number_of_smelters)

#@title Number of Refineries to Display

import ipywidgets as widgets
from IPython.display import display

number_of_refineries = widgets.IntText(
    value=25,
    description='Number of Refineries to Display:',
    disabled=False
)

display(number_of_refineries)

#@title Remove 'Other' Category For All Facility Layers


from ipywidgets import Checkbox
from IPython.display import display

checkbox = Checkbox(value=False, description='Remove \'Other\' Category', indent=False)

display(checkbox)

def on_value_change(change):
    print(f"Checkbox value changed to: {change['new']}")

checkbox.observe(on_value_change, names='value')

#@title Include additional facilities (Ignore This)

include_additional_facilities = True # leave as True

#@title Search for facility by country (**Does not affect diagram** - for your convenience - to more easily find some facility by country)

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output

temp_mines_df = init_mines_df.copy()
temp_smelters_df = init_smelters_df.copy()
temp_refineries_df = init_refineries_df.copy()

df1 = pd.concat([temp_mines_df, temp_smelters_df, temp_refineries_df])
df1 = df1.sort_values(by='Country')

search_box_1 = widgets.Text(
    placeholder='Type to search...',
    description='Search:',
    layout=widgets.Layout(width='50%')
)

multi_select_1 = widgets.SelectMultiple(
    options=sorted(df1['Country'].unique().tolist()),
    description='Select:',
    rows=6,
    layout=widgets.Layout(width='50%')
)

output_area_1 = widgets.Output()

def on_search_change(change):
    query = change['new'].lower()
    if query:
        filtered = [item for item in df1['Country'].unique().tolist() if query in item.lower()]
    else:
        filtered = sorted(df1['Country'].unique().tolist())

    current_selection = [item for item in multi_select_1.value if item in filtered]
    multi_select_1.options = filtered
    multi_select_1.value = tuple(current_selection)

def on_selection_change(change):
    with output_area_1:
        clear_output()
        selected = list(change['new'])
        if selected:
            display(df1[df1['Country'].isin(selected)])
        else:
            display(df1)

search_box_1.observe(on_search_change, names='value')
multi_select_1.observe(on_selection_change, names='value')

display(search_box_1, multi_select_1, output_area_1)

with output_area_1:
    display(df1)

#@title Select specific mine to be displayed

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output

df2 = pd.DataFrame({
    'Mine': init_mines_df['Mine'],
    'Country': init_mines_df['Country'],
    'Weight (kg)': init_mines_df[2022.0] * 1000000
})

search_box2 = widgets.Text(
    placeholder='Type to search...',
    description='Search:',
    layout=widgets.Layout(width='50%')
)

multi_select2 = widgets.SelectMultiple(
    options=df2['Mine'].tolist(),
    description='Select:',
    rows=6,
    layout=widgets.Layout(width='50%')
)

output_area2 = widgets.Output()

def on_search_change(change):
    query = change['new'].lower()
    if query:
        filtered = [item for item in df2['Mine'].tolist() if query in item.lower()]
    else:
        filtered = df2['Mine'].tolist()

    current_selection = [item for item in multi_select2.value if item in filtered]
    multi_select2.options = filtered
    multi_select2.value = tuple(current_selection)

def on_selection_change(change):
    with output_area2:
        clear_output()
        selected = list(change['new'])
        if selected:
            display(df2[df2['Mine'].isin(selected)])
        else:
            display(df2)

search_box2.observe(on_search_change, names='value')
multi_select2.observe(on_selection_change, names='value')

display(search_box2, multi_select2, output_area2)

with output_area2:
    display(df2)

#@title Select specific smelter to be displayed

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output

df3 = pd.DataFrame({
    'Smelter': init_smelters_df['Smelters'],
    'Country': init_smelters_df['Country'],
    'Weight (kg)': init_smelters_df[2022.0] * 1000000
})

search_box3 = widgets.Text(
    placeholder='Type to search...',
    description='Search:',
    layout=widgets.Layout(width='50%')
)

multi_select3 = widgets.SelectMultiple(
    options=df3['Smelter'].tolist(),
    description='Select:',
    rows=6,
    layout=widgets.Layout(width='50%')
)

output_area3 = widgets.Output()

def on_search_change(change):
    query = change['new'].lower()
    if query:
        filtered = [item for item in df3['Smelter'].tolist() if query in item.lower()]
    else:
        filtered = df3['Smelter'].tolist()

    current_selection = [item for item in multi_select3.value if item in filtered]
    multi_select3.options = filtered
    multi_select3.value = tuple(current_selection)

def on_selection_change(change):
    with output_area3:
        clear_output()
        selected = list(change['new'])
        if selected:
            display(df3[df3['Smelter'].isin(selected)])
        else:
            display(df3)

search_box3.observe(on_search_change, names='value')
multi_select3.observe(on_selection_change, names='value')

display(search_box3, multi_select3, output_area3)

with output_area3:
    display(df3)

#@title Select specific refinery to be displayed

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output

df4 = pd.DataFrame({
    'Refinery': init_refineries_df['Refineries'],
    'Country': init_refineries_df['Country'],
    'Weight (kg)': init_refineries_df[2022.0] * 1000000
})

search_box4 = widgets.Text(
    placeholder='Type to search...',
    description='Search:',
    layout=widgets.Layout(width='50%')
)

multi_select4 = widgets.SelectMultiple(
    options=df4['Refinery'].tolist(),
    description='Select:',
    rows=6,
    layout=widgets.Layout(width='50%')
)

output_area4 = widgets.Output()

def on_search_change(change):
    query = change['new'].lower()
    if query:
        filtered = [item for item in df4['Refinery'].tolist() if query in item.lower()]
    else:
        filtered = df4['Refinery'].tolist()

    current_selection = [item for item in multi_select4.value if item in filtered]
    multi_select4.options = filtered
    multi_select4.value = tuple(current_selection)

def on_selection_change(change):
    with output_area4:
        clear_output()
        selected = list(change['new'])
        if selected:
            display(df4[df4['Refinery'].isin(selected)])
        else:
            display(df4)

search_box4.observe(on_search_change, names='value')
multi_select4.observe(on_selection_change, names='value')

display(search_box4, multi_select4, output_area4)

with output_area4:
    display(df4)

#@title Number of Top Ranking Countries by Exports to Display

import ipywidgets as widgets
from IPython.display import display

int_box = widgets.IntText(
    value=5,
    description='Number of Top Ranking Countries by Exports to be Displayed:',
    disabled=False
)

display(int_box)

#@title Manually Add Countries to Include in Sankey Diagram


import ipywidgets as widgets
from IPython.display import display, clear_output
import plotly.graph_objects as go
from ipywidgets import GridspecLayout



reporter_countries = all_df['reporterDesc'].unique().tolist()
partner_countries = all_df['partnerDesc'].unique().tolist()
all_countries = sorted(list(set(reporter_countries + partner_countries)))

n_countries = len(all_countries)

checkboxes = {
    label: widgets.Checkbox(value=False, description=label)
    for label in all_countries
}
countries_to_keep = [False] * n_countries


def on_change(change):
    for label, checkbox in checkboxes.items():
      for i in range(n_countries):
        if all_countries[i] == label:
          countries_to_keep[i] = checkbox.value
    print(countries_to_keep)



grid = GridspecLayout(int(n_countries/5) + 1, 5)

row = 0
col = 0
for label, cb in checkboxes.items():
    cb.observe(on_change, names='value')
    grid[row, col] = cb
    col += 1
    if col >= 5:
        col = 0
        row += 1

display(grid)

#@title Latest Sankey Diagram
# import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import numpy as np
import plotly.express as px
import itertools
import random
import matplotlib.colors as mcolors

# pyinstaller --onefile --add-data "Copper_3_Types_(2603_7403_7404)_All_Years.csv:." run_app.py
# streamlit run copper_1.py

# st.set_page_config(page_title="Dynamic Copper Flows Sankey Diagram", layout="wide")

# st.markdown("""
#     <style>
#         html, body, [class*="css"] {
#             font-size: 18px !important;
#         }

#         div[data-testid="stMultiselect"] > label,
#         div[data-testid="stSelectbox"] > label {
#             white-space: normal !important;
#             overflow-wrap: break-word !important;
#             display: block !important;
#         }

#         div[data-testid="stSidebar"] {
#             min-width: 320px;
#         }

#         .block-container {
#             max-width: 100% !important;
#         }
#         .stMultiSelect [data-baseweb="select"] span {
#         max-width: 800px;
#         # white-space: normal;
#         overflow: visible;
#         text-overflow: clip;
#         }

#         .stMultiSelect [data-baseweb="select"] > div > div {
#             /* max-height: 200px;
#             /* overflow-y: auto; */
#         }
#     </style>
# """, unsafe_allow_html=True)





# st.title("Dynamic Copper Flows Sankey Diagram")

# import os
# import sys

# def resource_path(relative_path):
#     try:
#         base_path = sys._MEIPASS
#     except AttributeError:
#         base_path = os.path.abspath(os.path.dirname(__file__))

#     return os.path.join(base_path, relative_path)

# csv_file_name = "(2)_copper_May_19.csv"
# # csv_file_name = "copper_all_May_19.csv"
# # csv_file_name = "Copper_3_Types_(2603_7403_7404)_All_Years.csv"
# csv_path = resource_path(csv_file_name)

# try:
#     all_df = pd.read_csv(csv_path)
# except FileNotFoundError:
#     print(f"Error: CSV file not found at {csv_path}")
# except Exception as e:
#     print(f"An error occurred while loading the CSV: {e}")


# all_df = pd.read_csv('./(2)_copper_May_19.csv')
# all_df = pd.read_csv('./drive/MyDrive/Nserc/(2)_copper_May_19.csv')

# all_df = pd.read_csv('./drive/MyDrive/Nserc/2022_Sankey_July_21.csv')
# facilities_df = pd.read_csv('./drive/MyDrive/Nserc/facilities.csv')
# commodities_df = pd.read_csv('./drive/MyDrive/Nserc/commodities.csv')




"""## **WARNING:** (To be deleted in distributed version?): Up to viewer to **choose** adjacent flows that make sense.

**(1)**

**Flows** might be completely unrelated to other adjacent flows. For example, **flow 1** could be **waste**, and **flow 2** could also be **waste**. This doesn't make sense, as it is unlikely that the waste imported in flow 1 will be exported in flow 2.

**This is a limitation of the dataset**, as we only know total exports and imports to a country, and not what proportion of the country's imports compose its exports (of a specific copper type).

**(2)**

**Also:**

**It is unknown** if import streams and export streams are connected. Flow 1 might be **unrefined copper ore**, and flow 2 might be **refined copper**. While we know layer 2 imports from flow 1, and exports to flow 2, it is unknown if the copper from flow 1 after being processed/used/etc is really passed on to flow 2 (and not copper from some other input stream).

**I did not realize this initially**, I leave whether to include or not include this feature at your discretion.

**To avoid this ambiguity,** one can ignore this feature (of optionally having multiple flows) and only select one flow at a time.

**A suggested ordering of flows:** Unrefined Copper Ore (2603) -> Refined Copper (7403) -> Copper Waste (7404)

-----------------------------------------------

**Select Copper Types:**

By selecting a copper type, you are adding a flow to a sankey diagram, which models the export flow of the specified copper type from one layer to the next. This corresponds from left to right in the Sankey diagram. (Ex. flow 1 goes from layer 1 to layer 2) See sidebar (left) to view selected flows.

\*More options available with a larger dataset
"""


copper_type = ["Copper ores and concentrates", "Copper; unrefined, copper anodes for electrolytic refining", "Copper; refined and copper alloys, unwrought"]

selected_years = [2022]




metric_options = 'Net Weight (kg)'

if metric_options == 'Trade Value (USD)':
    metric = 'primaryValue'
else:
    metric = 'netWgt'

country_name_map = {
    #REDACTED
}

country_name_map_new = {v: k for k, v in country_name_map.items()}




## Create list of dataframes filtering for relevant entries
def create_dataframes(new_df, selected_years, copper_type, flow, layers):
  for i in range(layers-1):
    df = new_df
    df = df[df['cmdDesc'] == copper_type[i]]
    df = df[df['partnerDesc'] != "World"]
    df = df[df['flowDesc'] == "Export"]
    # df = df[(df['flowDesc'] == "Import") | (df['flowDesc'] == "Export")]
    df = df[df['refYear'].isin(selected_years)]
    dataframes.append(df)


## Filter countries from Dataframe in list 'groupby_df'
def replace_with_other(entity, groupby_df, index):
  for i, country in enumerate(groupby_df):
    if country in countries_to_keep:
        continue
    global dataframes
    dataframes[index].loc[dataframes[index][entity] == country, entity] = "Other"


## Collect countries to be excluded
def filter_countries(dataframe, entity, dataframe_index):
    groupby_df = dataframe.groupby(entity)[metric].sum()
    groupby_df = groupby_df.sort_values(ascending=False)
    groupby_df = groupby_df.index[int_box.value:].tolist()
    replace_with_other(entity, groupby_df, dataframe_index)


## Identify Top Ranking Countries by Export Quantity
def identify_top_ranking_countries(dataframes):
  for index, dataframe in enumerate(dataframes):
    if index < (len(dataframes) - 1):
      filter_countries(dataframe, 'reporterDesc', index)
    else:
      filter_countries(dataframe, 'reporterDesc', index)
      filter_countries(dataframe, 'partnerDesc', index)



## Filter out flow types from Dataframe that are not of type 'Export'
def filter_export_entries(dataframes):
  for dataframe in dataframes:
    dataframe = dataframe[dataframe['flowDesc'] == "Export"]

### =====================================================
### =====================================================
### =====================================================


## Create labels (nodes in Sankey Diagram)
def create_labels(dataframes, labels, sizes):
  for index, dataframe in enumerate(dataframes):
    if index == 0:
      new_labels = list(set(dataframes[index]['reporterDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))
    elif index < (len(dataframes) - 1):
      new_labels = list(set(dataframes[index]['reporterDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))

      new_labels = list(set(dataframes[index]['reporterDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))
    else:
      new_labels = list(set(dataframes[index]['reporterDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))

      new_labels = list(set(dataframes[index]['reporterDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))

      new_labels = list(set(dataframe['partnerDesc'].tolist()))
      labels.extend(new_labels)
      sizes.append(len(labels))

### =====================================================
### =====================================================
### =====================================================



source = []
target = []
values = []

aggregate_source = []
aggregate_target = []
aggregate_values = []


flow = "Export"
layers = len(copper_type) + 1

### =====================================================
number_of_copper_types = len(copper_type)
number_of_new_layers = number_of_copper_types*2
### =====================================================


dataframes = []

new_df = all_df

create_dataframes(new_df, selected_years, copper_type, flow, layers)

filter_export_entries(dataframes)


identify_top_ranking_countries(dataframes)

sizes = [0]
labels = []

create_labels(dataframes, labels, sizes)

Other = []

## Create category 'Other'
for k in range(number_of_new_layers):
  for i in range(sizes[k], sizes[k+1]):
    if labels[i] == "Other":
       Other.append(i)

colors = itertools.cycle(px.colors.qualitative.Plotly)
temp_color = next(colors)
flow_colors = []
legend_colors = []



def rgba_with_opacity(color, alpha=0.5):
    rgba = mcolors.to_rgba(color, alpha=alpha)
    return f'rgba({int(rgba[0]*255)}, {int(rgba[1]*255)}, {int(rgba[2]*255)}, {rgba[3]:.2f})'



### =====================================================
### =====================================================
### =====================================================



# indexes = [0,1,2,3,4,5]
## layer 0 => size 0 size 1
## layer 1 => size 1 size 2
## layer 2 => size 2 size 3
## layer 3 => size 3 size 4
## layer 4 => size 4 size 5
## layer 5 => size 5 size 6

sum = 0

## Set parameters to Sankey Diagram (source,target,value)
for k in range(len(dataframes)):
  # temp_color = random_color(opacity=0.3)
  temp_color = rgba_with_opacity(next(colors), 0.5)
  for index, row in dataframes[k].iterrows():
    for i in range(sizes[k*2], sizes[k*2+1]):
      if row['reporterDesc'] == labels[i]:
          source.append(i)
          break
    exists = False
    for j in range(sizes[k*2+1], sizes[k*2+2]):
      if row['partnerDesc'] == labels[j]:
          target.append(j)
          exists = True
          break
    if exists == False:
      target.append(Other[k*2+1])
    sum += 1
    values.append(row[metric])
    flow_colors.append(temp_color)
  legend_colors.append(temp_color)

### =====================================================
### =====================================================
country_name_variations = {
    #REDACTED
}

mines_df = init_mines_df
smelters_df = init_smelters_df
refineries_df = init_refineries_df

country_mines_to_keep = multi_select2.value
country_smelters_to_keep = multi_select3.value
country_refineries_to_keep = multi_select4.value

remove_other = checkbox.value

if remove_other:
  if include_additional_facilities:
    sorted_df = mines_df.sort_values(by=2022.0, ascending=False)
    mines_to_keep = sorted_df[:number_of_mines.value]
    mines_to_keep_by_country_list = mines_df[mines_df['Mine'].isin(country_mines_to_keep)]
    mines_df = pd.concat([mines_to_keep, mines_to_keep_by_country_list]).drop_duplicates(subset=['Mine']).sort_index()

    sorted_df = smelters_df.sort_values(by=2022.0, ascending=False)
    smelters_to_keep = sorted_df[:number_of_smelters.value]
    smelters_to_keep_by_country_list = smelters_df[smelters_df['Smelters'].isin(country_smelters_to_keep)]
    smelters_df = pd.concat([smelters_to_keep, smelters_to_keep_by_country_list]).drop_duplicates(subset=['Smelters']).sort_index()

    sorted_df = refineries_df.sort_values(by=2022.0, ascending=False)
    refineries_to_keep = sorted_df[:number_of_refineries.value]
    refineries_to_keep_by_country_list = refineries_df[refineries_df['Refineries'].isin(country_refineries_to_keep)]
    refineries_df = pd.concat([refineries_to_keep, refineries_to_keep_by_country_list]).drop_duplicates(subset=['Refineries']).sort_index()

  else:
    sorted_df = mines_df.sort_values(by=2022.0, ascending=False)
    mines_df = sorted_df[:number_of_mines.value].sort_index()

    sorted_df = smelters_df.sort_values(by=2022.0, ascending=False)
    smelters_df = sorted_df[:number_of_smelters.value].sort_index()

    sorted_df = refineries_df.sort_values(by=2022.0, ascending=False)
    refineries_df = sorted_df[:number_of_refineries.value].sort_index()
else:

  if include_additional_facilities:





    mines_to_keep_by_country_list = mines_df[mines_df['Mine'].isin(country_mines_to_keep)]
    mines_to_save_by_country_list = mines_df[~mines_df['Mine'].isin(country_mines_to_keep)]

    sorted_df = mines_to_save_by_country_list.sort_values(by=2022.0, ascending=False)
    mines_to_save_by_country_list.loc[sorted_df.index[number_of_mines.value:], 'Mine'] = 'Other'
    mines_df = pd.concat([mines_to_save_by_country_list, mines_to_keep_by_country_list]).sort_index()




    smelters_to_keep_by_country_list = smelters_df[smelters_df['Smelters'].isin(country_smelters_to_keep)]
    smelters_to_save_by_country_list = smelters_df[~smelters_df['Smelters'].isin(country_smelters_to_keep)]

    sorted_df = smelters_to_save_by_country_list.sort_values(by=2022.0, ascending=False)
    smelters_to_save_by_country_list.loc[sorted_df.index[number_of_smelters.value:], 'Smelters'] = 'Other'
    smelters_df = pd.concat([smelters_to_save_by_country_list, smelters_to_keep_by_country_list]).sort_index()





    refineries_to_keep_by_country_list = refineries_df[refineries_df['Refineries'].isin(country_refineries_to_keep)]
    refineries_to_save_by_country_list = refineries_df[~refineries_df['Refineries'].isin(country_refineries_to_keep)]

    sorted_df = refineries_to_save_by_country_list.sort_values(by=2022.0, ascending=False)
    refineries_to_save_by_country_list.loc[sorted_df.index[number_of_refineries.value:], 'Refineries'] = 'Other'
    refineries_df = pd.concat([refineries_to_save_by_country_list, refineries_to_keep_by_country_list]).sort_index()





  else:
    sorted_df = mines_df.sort_values(by=2022.0, ascending=False)
    mines_df.loc[sorted_df.index[number_of_mines.value:], 'Mine'] = 'Other'

    sorted_df = smelters_df.sort_values(by=2022.0, ascending=False)
    smelters_df.loc[sorted_df.index[number_of_smelters.value:], 'Smelters'] = 'Other'

    sorted_df = refineries_df.sort_values(by=2022.0, ascending=False)
    refineries_df.loc[sorted_df.index[number_of_refineries.value:], 'Refineries'] = 'Other'





mine_labels = mines_df['Mine'].tolist()
smelter_labels = smelters_df['Smelters'].tolist()
refineries_labels = refineries_df['Refineries'].tolist()

mine_labels.append("Other")
smelter_labels.append("Other")
refineries_labels.append("Other")



labels = labels + mine_labels

mine_labels_size = len(labels)

labels = labels + smelter_labels

smelter_labels_size = len(labels)

labels = labels + refineries_labels

refineries_labels_size = len(labels)




temp_color = rgba_with_opacity(next(colors), 0.5)

first_layer_other = -1

for index, row in mines_df.iterrows():
  sum += 1
  if row['Mine'] in (labels[sizes[-1]:mine_labels_size]):
    for i in range(sizes[-1], mine_labels_size):
      if labels[i] == row['Mine']:
        source.append(i)
        break
  else:
    source.append(mine_labels_size - 1)
  if row['Country'] in country_name_map_new:
    if country_name_map_new[row['Country']] in labels[sizes[0]:sizes[1]]:
      for j in range(sizes[0], sizes[1]):
        if labels[j] == row['Country']:
          target.append(j)
          break
    else:
      target.append(Other[0])
  else:
    target.append(Other[0])
  values.append(row[2022.0] * 1000000)
  flow_colors.append(temp_color)
legend_colors.append(temp_color)

# print(2)
# print(len(source))
# print(len(target))
# print(len(values))






## other
## have to match sources and target number -> start from sizes[-1]

# added_labels = commodities_df["facility_id"].unique().tolist()

# mines
## layer 0 => size 0 size 1
## layer 1 => size 1 size 2
# smelter
## layer 2 => size 2 size 3
## layer 3 => size 3 size 4
# refineries
## layer 4 => size 4 size 5
## layer 5 => size 5 size 6

### =====================================================
ore_concentrate_mask = []
anode_mask = []
cathode_mask = []

# flag = False

# Create labels
for index, row in smelters_df.iterrows():
  sum += 2
  if row['Country'] in country_name_map_new:
    if country_name_map_new[row['Country']] in labels[sizes[1]:sizes[2]]:
      for i in range(sizes[1], sizes[2]):
        if country_name_map_new[row['Country']] == labels[i]:
          source.append(i)
          break
    else:
      source.append(Other[1])
  else:
    source.append(Other[1])
  for k in range(mine_labels_size, smelter_labels_size):
    if labels[k] == row['Smelters']:
      target.append(k)
      source.append(k)
      break
  if row['Country'] in country_name_map_new:
    if country_name_map_new[row['Country']] in labels[sizes[2]:sizes[3]]:
      for j in range(sizes[2], sizes[3]):
        if country_name_map_new[row['Country']] == labels[j]:
          target.append(j)
          break
    else:
      target.append(Other[2])
  else:
    target.append(Other[2])
  values.append(row[2022.0] * 1000000)
  values.append(row[2022.0] * 1000000)
  flow_colors.append(temp_color)
  flow_colors.append(temp_color)
      # legend_colors.append(temp_color)

# print(3)
# print(len(source))
# print(len(target))
# print(len(values))
# print(sum)

for index, row in refineries_df.iterrows():
  sum += 2
  if row['Country'] in country_name_map_new:
    if country_name_map_new[row['Country']] in labels[sizes[3]:sizes[4]]:
      for i in range(sizes[3], sizes[4]):
        if country_name_map_new[row['Country']] == labels[i]:
          source.append(i)
          break
    else:
      source.append(Other[3])
  else:
    source.append(Other[3])
  for k in range(smelter_labels_size, refineries_labels_size):
    if labels[k] == row['Refineries']:
      target.append(k)
      source.append(k)
      break
  if row['Country'] in country_name_map_new:
    if country_name_map_new[row['Country']] in labels[sizes[4]:sizes[5]]:
      for j in range(sizes[4], sizes[5]):
        if country_name_map_new[row['Country']] == labels[j]:
          target.append(j)
          break
    else:
      target.append(Other[4])
  else:
    target.append(Other[4])
  values.append(row[2022.0] * 1000000)
  values.append(row[2022.0] * 1000000)
  flow_colors.append(temp_color)
  flow_colors.append(temp_color)
      # legend_colors.append(temp_color)


# print(4)
# print(len(source))
# print(len(target))
# print(len(values))


# add extra label for fake smelter/refinery
for i in range(sizes[1], sizes[2]):
  if i not in source:
    source.append(i)
    labels.append("Placeholder Smelter")
    target.append(len(labels) - 1)
    source.append(len(labels) - 1)
    for j in range(sizes[2], sizes[3]):
      if labels[i] == labels[j]:
        target.append(j)
        break
    values.append(1)
    values.append(1)
    flow_colors.append(temp_color)
    flow_colors.append(temp_color)

for i in range(sizes[3], sizes[4]):
  if i not in source:
    source.append(i)
    labels.append("Placeholder Refinery")
    target.append(len(labels) - 1)
    source.append(len(labels) - 1)
    for j in range(sizes[4], sizes[5]):
      if labels[i] == labels[j]:
        target.append(j)
        break
    values.append(1)
    values.append(1)
    flow_colors.append(temp_color)
    flow_colors.append(temp_color)


# print(5)
# print(len(source))
# print(len(target))
# print(len(values))
### =====================================================


## Aggregate values
df = pd.DataFrame({'source': source, 'target': target, 'value': values, 'color': flow_colors})
df_aggregate = df.groupby(['source', 'target', 'color'], as_index=False).sum()

aggregate_source = df_aggregate['source'].tolist()
aggregate_target = df_aggregate['target'].tolist()
aggregate_values = df_aggregate['value'].tolist()
aggregate_colors = df_aggregate['color'].tolist()

# df = pd.DataFrame({'source': source, 'target': target, 'value': values})
# df_aggregate = df.groupby(['source', 'target'], as_index=False).sum()

# aggregate_source = df_aggregate['source'].tolist()
# aggregate_target = df_aggregate['target'].tolist()
# aggregate_values = df_aggregate['value'].tolist()

colors = itertools.cycle(px.colors.qualitative.Plotly)
node_colors = [next(colors) for _ in labels]

## Create Sankey Diagram


fig = go.Figure(go.Sankey(
    node=dict(
        pad=15,
        thickness=20,
        # line=dict(color="black", width=0.5),
        color=node_colors,
        label=labels,
        align="right",
    ),
    link=dict(
        arrowlen=15,
        source=aggregate_source,
        target=aggregate_target,
        value=aggregate_values,
        color=aggregate_colors
    )
))

#Change Diagram Title
fig.update_layout(
    title_text="Top Countries (By Exports - NOT IMPORTS)" + " based on " + metric,
    # font=dict(
        # size=20,
        # color="black"
    # ),
    width=1600,
    height=800,
    hoverlabel=dict(
        font_size=20
    )
)
fig.show()
# st.plotly_chart(fig, use_container_width=True)

# st.sidebar.markdown("**Selected Flows:**")
# for i, flow in enumerate(copper_type):
#     st.sidebar.markdown(
#         f'<span style="background-color: {legend_colors[i]}; color: black; padding: 4px; border-radius: 4px;">'
#         f'Flow {i+1}: {flow}</span>',
#         unsafe_allow_html=True
#     )
    # st.sidebar.markdown(f'<span style="color: {legend_colors[i]};">Flow {i+1}: {flow}</span>', unsafe_allow_html=True)
    # st.sidebar.write(f"Flow {i+1}: {flow}")

# """**"Other"**, is a category representing an aggregation of all countries not shown for a particular flow/layer.

# **Layers** are ordered from left to right, with export flows between layers also going from left to right. Reference left sidebar for
# particular copper type specified per flow.

# **Flows** represent the movement of copper across layers (from left to right).

# **Note:** Countries per layer are selected to be shown based on **export** quantity (flow magnitude to the right of the layer), **NOT** based on **import** quantity (flow to the left of layer).
# """

"""**Flows:**

---

**Layer 1** (leftmost): Mines

**Layer 2:** Countries exporting HS 2603 (Copper Concentrate)

---

**Layer 3:** Countries importing HS 2603

**Layer 4:** Smelters

**Layer 5:** Countries exporting HS 7402 (Copper Anodes)

---

**Layer 6:** Countries importing HS 7402

**Layer 7:** Refineries

**Layer 8:** Countries exporting HS 7403 (Copper Cathodes)

---

**Layer 9:** Countries importing HS 7403
"""