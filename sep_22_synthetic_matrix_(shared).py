# -*- coding: utf-8 -*-
"""Sep 22 Synthetic Matrix (Shared).ipynb

Automatically generated by Colab.

# This code allows for testing a synthetic matrix, where the synthetic matrix can be configured, depending on what conditions one wants to simulate.

**Size of Matrix**

x_dim = 10

y_dim = 10

**Highest and lowest value in matrix**

  highest_value = 100
  
  lowest_value = 20

**Random Seed**

  seed = 43

**Size of submatrix constraint**

  submatrix = 5

**This is an option which allows the user to select the distribution of the number of zeros per row. If set to false, it will select 2,3,or 4 non-zeros for each row with equal probability. If set to true, it can select anywhere between 1 and 10 non-zeros per row. It will select this based on a normal distribution, where the average is 3 and the standard deviation is 2.**

  sparsity = True

**Number of flows which we know to exist**

**A quick note about this: you cannot set the heuristic value to be greater than the number of non-zeros present in the matrix. Also: If lets say 100 was set as the heuristic_value, the algorithm will automatically choose 100 values in the matrix, upon which we say we 'know' they are non-zero. Essentially, this value represents the power of our heuristic (which is incomplete at this time)**

  heuristic_value = 100


**Designed to test the compatibility heuristic.**

**This tells us the number of zeros in the matrix which we know about. It will randomly select some number of values in the matrix to be zero. These values it selects, correspond to actual zeros in the source matrix. The greater this number, the more accurate our estimation. However, at this point in time, we do not know what this number would be for the real matrix.**

  number_of_zero_entries = 0

# Functions
"""

#@title Initial Synthetic Matrix2

import math
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

def create_matrix2(low, high, x_dim, y_dim, seed, sparsity=False, avg=3):

  rng = np.random.default_rng(seed=seed)

  matrix = np.zeros((x_dim, y_dim), dtype=int)

  for i in range(matrix.shape[0] - 1):
      if sparsity:
        values = np.arange(1, 10)
        # values = np.arange(2, 11)
        # mean = 5
        mean = avg
        std = 2
        probs = np.exp(-0.5 * ((values - mean) / std) ** 2)
        probs /= probs.sum()
        num_entries = rng.choice(values, p=probs)
        # num_entries = int(np.clip(rng.choice(values, p=probs), 2, 10))

        # num_entries = int(np.clip(np.round(rng.normal(loc=2, scale=2)), 2, 10))
        # num_entries = rng.choice(np.arange(2, 11), p=[0.25, 0.2, 0.15, 0.1, 0.1, 0.05, 0.05, 0.05, 0.05])
      else:
        num_entries = rng.choice(np.arange(2, 4))
      row_indices = rng.choice(matrix.shape[1] - 1, num_entries, replace=False)
      for j in row_indices:
          matrix[i,j] = rng.integers(low, high)
          # matrix[i,j] = rng.integers(50, 100)

  for i in range(matrix.shape[0]):
      matrix[i,-1] = 0
      matrix[i,-1] = np.sum(matrix[i,:])

  for j in range(matrix.shape[1]):
      matrix[-1,j] = 0
      matrix[-1,j] = np.sum(matrix[:,j])

  matrix = matrix.astype(int)

  row_index_tuples = []
  col_index_tuples = []

  for i in range(matrix.shape[0]-1):
    index = math.floor(i/3) + 1
    row_index_tuples.append(('Country ' + str(index), 'Mine ' + str(i + 1)))

  for j in range(matrix.shape[1]-1):
    index = math.floor(j/3) + 1
    col_index_tuples.append(('Country ' + str(index), 'Smelter ' + str(j + 1)))


  row_index = pd.MultiIndex.from_tuples(
      row_index_tuples +
      # [('Chile', 'Mine 1'),
      # ('Chile', 'Mine 2'),
      # ('Chile', 'Mine 3'),
      # ('China', 'Mine 4'),
      # ('China', 'Mine 5'),
      # ('China', 'Mine 6'),
      # ('Peru',  'Mine 7'),
      # ('Peru',  'Mine 8'),
      # ('Peru',  'Mine 9'),
      [('', 'Sum of Smelters')],
      # ],
      names=['Country', 'Mine']
  )

  col_index = pd.MultiIndex.from_tuples(
      col_index_tuples +
      # [('Chile', 'Smelter 1'),
      # ('Chile', 'Smelter 2'),
      # ('Chile', 'Smelter 3'),
      # ('China', 'Smelter 4'),
      # ('China', 'Smelter 5'),
      # ('China', 'Smelter 6'),
      # ('Peru',  'Smelter 7'),
      # ('Peru',  'Smelter 8'),
      # ('Peru',  'Smelter 9'),
      [('',  'Sum of Mines')],
      # ],
      names=['Country', 'Smelter']
  )

  if show:
    df1 = pd.DataFrame(matrix, index=row_index, columns=col_index)

    plt.figure(figsize=(8, 6))
    sns.heatmap(df1, annot=True, fmt='d', cmap='Blues')
    plt.title("True Matrix")
    plt.tight_layout()
    plt.show()

  return matrix, row_index, col_index

#@title Heuristic Matrix 6
import cvxpy as cp
import numpy as np

def heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, highest_value):

  rng2 = np.random.default_rng(seed=seed)

  heuristic_matrix = np.zeros((len(row_index)-1, len(col_index)-1))
  list_of_indices = []
  for i in range(heuristic_matrix.shape[0]):
    for j in range(heuristic_matrix.shape[1]):
      if 0 < matrix[i,j]:
        list_of_indices.append((i,j))

  h_indices = rng2.choice(list_of_indices, number_of_heuristic_entries, replace=False)

  if matrix.shape[0] > matrix.shape[1]:
    for i,j in h_indices:
      heuristic_matrix[i,j] = matrix[i,-1]
  else:
    for i,j in h_indices:
      heuristic_matrix[i,j] = matrix[-1,j]

  heuristic_matrix_instance = heuristic_matrix.astype(int)

  if show:
    df2 = pd.DataFrame(heuristic_matrix_instance, index=row_index[:-1], columns=col_index[:-1])

    plt.figure(figsize=(8, 6))
    sns.heatmap(df2, annot=True, fmt='d', cmap='Blues')
    plt.title("Heuristic Matrix")
    plt.tight_layout()
    plt.show()

  heuristic_matrix_safe = heuristic_matrix_instance + 1e-6

  return heuristic_matrix_safe

#@title A b #2
def set_A_b(matrix, submatrix, row_index, col_index, number_of_zero_entries, seed):


    n_rows = len(row_index) - 1
    n_cols = len(col_index) - 1

    sum_of_rows = matrix[:-1, -1]
    sum_of_cols = matrix[-1, :-1]

    # Build submatrix sums
    submatrices = []
    for i in range(math.ceil(n_rows/submatrix)):
        for j in range(math.ceil(n_cols/submatrix)):
            r_slice = slice(i*submatrix, min((i+1)*submatrix, n_rows))
            c_slice = slice(j*submatrix, min((j+1)*submatrix, n_cols))
            submatrices.append(np.sum(matrix[:-1, :-1][r_slice, c_slice]))

    b = np.concatenate([sum_of_rows, sum_of_cols, submatrices])
    A = np.zeros((len(b), n_rows * n_cols))

    def idx(i,j): return i * n_cols + j

    # Row sums
    for i in range(n_rows):
        for j in range(n_cols):
            A[i, idx(i,j)] = 1

    # Column sums
    for j in range(n_cols):
        for i in range(n_rows):
            A[n_rows + j, idx(i,j)] = 1

    # Submatrix sums
    k = n_rows + n_cols
    for i in range(math.ceil(n_rows/submatrix)):
        for j in range(math.ceil(n_cols/submatrix)):
            r_slice = slice(i*submatrix, min((i+1)*submatrix, n_rows))
            c_slice = slice(j*submatrix, min((j+1)*submatrix, n_cols))
            temp = np.zeros((n_rows, n_cols))
            temp[r_slice, c_slice] = 1
            A[k] = temp.flatten()
            k += 1

    return A, b

#@title Linear Programming 3

import cvxpy as cp
import random
import scipy

def quad_prog_7(heuristic_matrix, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix=3):


  rng = np.random.default_rng(seed)

  n_rows = len(row_index) - 1
  n_cols = len(col_index) - 1

  P = cp.Variable((n_rows, n_cols))


  A, b = set_A_b(matrix, submatrix, row_index, col_index, number_of_zero_entries, seed)
  A = scipy.sparse.csr_matrix(A)
  s = cp.Variable(len(col_index[:-1]))
  s3 = cp.Variable(len(b) - len(row_index[:-1]) - len(col_index[:-1]))
 
  constraints = [
      cp.sum(P, axis=1) == matrix[:-1,-1],

      cp.sum(P, axis=0) + s == matrix[-1,:-1],
      P >= 0,
  ]
  k = 0
  for i in range(math.ceil((len(row_index)-1)/submatrix)):
    for j in range(math.ceil((len(col_index)-1)/submatrix)):
       constraints.append(cp.sum(P[i*submatrix:(i+1)*submatrix,j*submatrix:(j+1)*submatrix]) + s3[k] == np.sum(matrix[:-1,:-1][i*submatrix:(i+1)*submatrix,j*submatrix:(j+1)*submatrix]))
       k += 1
  # EDIT

  list_of_indices = [(i, j) for i in range(n_rows) for j in range(n_cols) if matrix[i, j] == 0]
  num_entries = min(number_of_zero_entries, len(list_of_indices))
  if num_entries > 0:
      q_indices = rng.choice(list_of_indices, num_entries, replace=False)
      for i, j in q_indices:
          constraints.append(P[i, j] == 0)


  # rho = 10000
  rho = 100

  delta = 1.0
  objective = cp.Minimize(cp.sum(cp.huber(P - P_prior, M=delta)) + cp.norm1(s) + rho *(cp.norm1(s3)))

  problem = cp.Problem(objective, constraints)
  problem.solve(warm_start=True)

  P_value = P.value
  P_value[P_value < 0.5] = 0

  sol_heuristic_matrix = np.zeros((len(row_index), len(col_index)))
  sol_heuristic_matrix[0:-1,0:-1] = P_value

  for i in range(sol_heuristic_matrix.shape[0]):
      sol_heuristic_matrix[i,-1] = np.sum(sol_heuristic_matrix[i,:])

  for j in range(sol_heuristic_matrix.shape[1]):
      sol_heuristic_matrix[-1,j] = np.sum(sol_heuristic_matrix[:,j])

  if show:
    df4 = pd.DataFrame(sol_heuristic_matrix, index=row_index, columns=col_index)

    plt.figure(figsize=(14, 10))
    sns.heatmap(df4, annot=True, fmt='.2f', cmap='Blues')
    plt.title("Quadratic Programming Heuristic Matrix")
    plt.tight_layout()
    plt.show()

  return sol_heuristic_matrix

"""# Test 9"""

#@title 25x25
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  x_dim = 25
  y_dim = 25
  # x_dim = 500
  # y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity)

  number_of_zero_entries = 0

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(0,10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break

    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()

y[-1]

#@title 50x50
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  x_dim = 50
  y_dim = 50
  # x_dim = 500
  # y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity)

  number_of_zero_entries = 0

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(0,10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break


    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()

y[-1]

#@title 25x25 Known zeros
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  x_dim = 25
  y_dim = 25
  # x_dim = 500
  # y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity)

  number_of_zero_entries = 300

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(0,10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break


    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()

y[-1]

"""# Test 10 (Latest Quad Prog 7)"""

#@title 25x25
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  x_dim = 25
  y_dim = 25
  # x_dim = 500
  # y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity)

  number_of_zero_entries = 0

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(0,10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break


    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()

#@title 25x25 known zeros = 300
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  x_dim = 25
  y_dim = 25
  # x_dim = 500
  # y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity)

  number_of_zero_entries = 300

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(0,10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break


    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      # print(np.mean(test_matrix))
      # print(np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()

"""# Test 11"""

#@title Linear programming norm | 500x100 | avg non-zero per row = 5
# Dimension = 10
# number_of_zero_entries = 30

# show = True
show = False
# show_printout = True
show_printout = False

P_prior = 0
matrix = 0
sol_heuristic_matrix = 0

def trials():
  x = []
  y = []


  # x_dim = 10
  # y_dim = 10
  # x_dim = 25
  # y_dim = 25
  x_dim = 500
  y_dim = 100
  # highest_value = 1000
  highest_value = 100
  lowest_value = 20
  seed = 43

  # Test different lambda
  lambda_reg = 1
  # lambda_reg = 10
  # lambda_reg = 0.0001
  # lambda_reg = 0.1
  # submatrix = 5
  submatrix = 3
  sparsity = True
  heuristic_value = 100

  matrix, row_index, col_index = create_matrix2(lowest_value, highest_value, x_dim, y_dim, seed, sparsity, avg=5)

  number_of_zero_entries = 0

  if number_of_zero_entries > matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]):
    number_of_zero_entries = matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1])

  print("Current number of set zero entries:", number_of_zero_entries)
  print("Total number of zero entries:", matrix[:-1,:-1].size - np.count_nonzero(matrix[:-1,:-1]))
  print("Total number of non-zero entries:", np.count_nonzero(matrix[:-1,:-1]))


  P_prior = 0
  sol_heuristic_matrix = 0
  for i in range(np.count_nonzero(matrix[:-1,:-1]),10000):
    number_of_heuristic_entries = i

    non_zero_count = np.count_nonzero(matrix[:-1,:-1])

    if number_of_heuristic_entries > non_zero_count:
      break


    # edit ---- Aug 21
    P_prior = heuristic_matrix_6(seed, number_of_heuristic_entries, row_index, col_index, matrix, heuristic_value)
    sol_heuristic_matrix = quad_prog_7(P_prior, row_index, col_index, matrix, lambda_reg, number_of_zero_entries, seed, P_prior, submatrix)
    # edit ----


    test_matrix = matrix[0:-1,0:-1] - sol_heuristic_matrix[0:-1,0:-1]
    test_matrix = np.abs(test_matrix)
    if show_printout:
      print("Number of flows known to exist:", i)
      print("Non-zero count", non_zero_count)
      print("Normalized Avg Cell Error:")
      print(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
      print()
    x.append(i)
    y.append(np.mean(test_matrix)/np.mean(matrix[0:-1,0:-1]))
  print('Total number of unknowns: ', matrix[:-1,:-1].size)
  return x, y, P_prior, matrix, sol_heuristic_matrix

x, y, P_prior, matrix, sol_heuristic_matrix = trials()


plt.scatter(x, y)
plt.title('Number of flows known to exist vs. Error rate')
plt.xlabel('Number of flows known to exist')
plt.ylabel('Error rate')

plt.show()